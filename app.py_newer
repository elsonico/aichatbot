#!/usr/bin/env python

from flask import Flask, request, jsonify, render_template, Response, stream_with_context
from flask_sqlalchemy import SQLAlchemy
import openai
import os, sys, re
import logging
import requests
from requests.adapters import HTTPAdapter
import json

logging.basicConfig(level=logging.DEBUG)

app = Flask(__name__)

# Database connection info from environment variables
hostname = os.getenv('DB_HOST', 'localhost')
databasename = os.getenv('DB_NAME', 'default_db_name')
username = os.getenv('DB_USER', 'default_user')
password = os.getenv('DB_PASS', 'default_password')
port = os.getenv('DB_PORT', '5432')  # Ensure default port is string

app.config['SQLALCHEMY_DATABASE_URI'] = f'postgresql://{username}:{password}@{hostname}/{databasename}'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)

# Azure OpenAI API settings
openai.api_type = "openai"
openai.api_key = os.getenv("OPENAI_API_KEY")
deployment_id = "gpt-4"

# Database models
class Chat(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    question = db.Column(db.String, nullable=False)
    answer = db.Column(db.String, nullable=False)
    feedback = db.Column(db.Boolean)

class KnowledgeBase(db.Model):
    __tablename__ = 'KnowledgeBase'
    id = db.Column(db.Integer, primary_key=True)
    question = db.Column(db.String(450), unique=True, nullable=False)
    answer = db.Column(db.String, nullable=False)

class DataEnrichmentAdapter(HTTPAdapter):
    def send(self, request, **kwargs):
        """ Modify request to enhance with external data from Azure SQL Database. """
        with db.engine.connect() as connection:
            result = connection.execute("SELECT * FROM KnowledgeBase WHERE question LIKE '%data%'")
            data_json = [{'question': row.question, 'answer': row.answer} for row in result]
        request.headers['X-Data-Reference'] = str(data_json)  # Adjust as necessary for API
        return super(DataEnrichmentAdapter, self).send(request, **kwargs)

# Setup the session with the custom adapter
session = requests.Session()
adapter = DataEnrichmentAdapter()
#session.mount(f"{openai.api_base}/openai/deployments/{deployment_id}", adapter)
#session.mount(f"{deployment_id}", adapter)
session.mount('https://api.openai.com', adapter)
openai.requestssession = session  # Ensure OpenAI uses the customized session

@app.route('/')
def home():
    return render_template('chat.html')

@app.route('/chat', methods=['POST', 'GET'])
def chat():
    if request.method == 'POST':
        user_input = request.json['question']
        return jsonify(process_post(user_input))
    elif request.method == 'GET':
        user_input = request.args.get('question')
        return Response(stream_with_context(stream_response(user_input)), mimetype='text/event-stream')
    else:
        return "Method Not Allowed", 405

def process_post(user_input):
    knowledge = KnowledgeBase.query.filter_by(question=user_input).first()
    if knowledge:
        return {'answer': knowledge.answer, 'chat_id': ''}
    
    response = openai.chat.completions.create(
        model=deployment_id,
        messages=[
            {"role": "system", "content": "You are a professional technical specialist. Your name is Tapio Vaattanen."},
            {"role": "user", "content": user_input}
        ]
    )
    answer = response.choices[0].message.content.strip()
    answer = format_response(answer)
    new_knowledge = KnowledgeBase(question=user_input, answer=answer)
    db.session.add(new_knowledge)
    db.session.commit()

    new_chat = Chat(question=user_input, answer=answer, feedback=None)
    db.session.add(new_chat)
    db.session.commit()
    return {'answer': answer, 'chat_id': new_chat.id}

def stream_response(user_input):
    """ Generator function to stream the response using Flask's application context. """
    with app.app_context():
        yield "data: Checking for cached answers...\n\n"
        knowledge = KnowledgeBase.query.filter_by(question=user_input).first()
        if knowledge:
            yield f"data: {json.dumps({'answer': knowledge.answer, 'chat_id': ''})}\n\n"
        else:
            yield "data: Fetching from AI model...\n\n"
            response = openai.chat.completions.create(
                model=deployment_id,
                messages=[
                    {"role": "system", "content": "You are a professional technical specialist. Your name is Tapio Vaattanen."},
                    {"role": "user", "content": user_input}
                ]
            )
            answer = response.choices[0].message.content.strip()
            answer = format_response(answer)
            new_knowledge = KnowledgeBase(question=user_input, answer=answer)
            db.session.add(new_knowledge)
            db.session.commit()

            new_chat = Chat(question=user_input, answer=answer, feedback=None)
            db.session.add(new_chat)
            db.session.commit()

            yield f"data: {json.dumps({'answer': answer, 'chat_id': new_chat.id})}\n\n"

def format_response(text):
    """
    Formats text by handling bold within numbered list items correctly,
    applying general text formatting, and managing code blocks.
    """
    formatted_text = ""
    in_code_block = False  # Flag to check if inside a code block
    buffer = ""  # Buffer to store text for code blocks

    lines = text.split('\n')
    for line in lines:
        if line.strip().startswith("```"):  # Check for code block toggle
            in_code_block = not in_code_block
            if not in_code_block:
                formatted_text += f"<pre><code>{buffer}</code></pre>"
                buffer = ""
            continue

        if in_code_block:
            buffer += line + '\n'
            continue

        # Handling bold within numbered list items
        search_result = re.search(r'^(\d+)\.\s+\*\*(.*?)\*\*:\s*(.*)$', line)
        if search_result:
            number, bold_text, the_rest = search_result.groups()
            formatted_text += f"<p>{number}. <strong>{bold_text}</strong>: {the_rest}</p>"
        else:
            # Apply bold text formatting for other lines
            line = re.sub(r'\*\*(.*?)\*\*', r'<strong>\1</strong>', line)
            formatted_text += f"<p>{line}</p>"

    # Ensure closing code block if text ends within one
    if in_code_block:
        formatted_text += f"<pre><code>{buffer}</code></pre>"

    return formatted_text

@app.after_request
def apply_cors(response):
    response.headers['X-Frame-Options'] = 'ALLOW-FROM https://nordcloud.atlassian.net'
    response.headers['Content-Security-Policy'] = "frame-ancestors 'self' https://nordcloud.atlassian.net"
    return response

if __name__ == '__main__':
    db.create_all() 
    app.run(debug=True, host='0.0.0.0', port=5000)
